---
title: "Working with ZXY data part 1"
author: "Andreas K. Winther"
date: "5/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction

In this post we'll do some basic data vizualization using the ZXY data from Pettersen et al 2014. 

```{r echo=FALSE, message=FALSE}
library(ggplot2)
install.packages("ggforce")
install.packages("Rcpp")
library(ggforce)
library(dplyr)
library(zoo)
```

The data can easily be imported by typing the followig code:
```{r}
df <- read.csv("http://home.ifi.uio.no/paalh/dataset/alfheim/2013-11-28/zxy/2013-11-28_tromso_tottenham_raw.csv", header = FALSE)
```

Let's start by changing the names of the variables, and adding a column with the time elapsed in seconds.
```{r}
names(df) <- c("timestamp", "tag_id", "x_pos", "y_pos", "heading", "direction", "energy", "speed", "total_distance")

options(digits.secs = 6)
df$timestamp <- as.POSIXct(df$timestamp,format = "%Y-%m-%d %H:%M:%OS")
df$seconds <- as.numeric(df$timestamp - min(df$timestamp))

df <- df %>%
  group_by(tag_id) %>%
  mutate(distance = (sqrt((x_pos - lag(x_pos))^2 + (y_pos - lag(y_pos))^2)),
         speed_km.h = (speed * 3.6), 
         hir_distance = (cumsum(ifelse(speed_km.h >=19.8 & speed_km.h <= 25.2, distance, 0))),
         sprint_distance = (cumsum(ifelse(speed_km.h > 25.2, distance, 0))),
         acceleration = c(NA, diff(speed)/diff(seconds)),
         accel_moderate = (ifelse(acceleration >= 2 & acceleration <= 4, acceleration, 0)),
         accel_high = (ifelse(acceleration > 4, acceleration, 0)),
         decel_moderate = (ifelse(acceleration <=-2 & acceleration >=-4, acceleration, 0)),
         decel_high = (ifelse(acceleration < -4, acceleration, 0)),
         vectorCompX = c(NA,diff(x_pos)),
         vectorCompY = c(NA, diff(y_pos)),
         vectorLength = sqrt(((vectorCompX^2) + (vectorCompY^2))),
         prodVectorLength = vectorLength * lead(vectorLength),
         dotProd = vectorCompX * lead(vectorCompX) + vectorCompY * lead(vectorCompY),
         angularDisp = rad2deg(acos(dotProd/prodVectorLength)),
         angularVelocity = abs(c(NA, diff(angularDisp)/diff(seconds)))) %>%
  arrange(tag_id)

rad2deg <- function(rad) {(rad * 180) / (pi)}

df_cleaned <- df %>%
  filter(!is.na(angularDisp) & !is.na(angularVelocity) & speed_km.h < 37 & acceleration < 6 & acceleration > -6) # & angularVelocity < 225 ) 

outliers <- subset(df, speed_km.h > 37 | angularVelocity > 270 | acceleration > 6 | acceleration < -6)

df_stats <- df_cleaned %>%
  group_by(tag_id, position) %>%
  summarise(total_distance = max(total_distance),
            sprint_distance = max(sprint_distance),
            sprint_counts = sum(rle(speed_km.h > 25.2)$values, na.rm = TRUE),
            hir_counts = sum(rle(speed_km.h >=19.8 & speed_km.h <= 25.2)$values, na.rm = TRUE),
            accel_mod_counts = sum(rle(acceleration >= 2 & acceleration <= 4)$values, na.rm = TRUE),
            accel_high_counts = sum(rle(acceleration > 4)$values, na.rm = TRUE),
            decel_mod_counts = sum(rle(acceleration <=-2 & acceleration >=-4)$values, na.rm = TRUE),
            decel_high_counts = sum(rle(acceleration < -4)$values, na.rm = TRUE))

#specific player datasets
player1 <- df_cleaned[df_cleaned$tag_id == "1",]

accCounter <- function(acceleration, accThreshold, timestamp, timeThreshold) {
  accVector <- vector("numeric", length = length(acceleration))
  for (i in 1:length(acceleration)) {
    if (acceleration[i] >= accThreshold) {
      accVector[i] = 1
    }
  }
  accIndex <- rle(accVector)
  accelIndexes <- cumsum(accIndex$lengths)
  if (length(accelIndexes) %% 2 == 1) {
    accelIndexes <- c(accelIndexes, accelIndexes[length(accelIndexes)])
  }
  accStart <- accelIndexes[seq(from = 1, to = length(accelIndexes), by = 2)]
  accEnd <- accelIndexes[seq(from = 2, to = length(accelIndexes), by = 2)]
  accStartStamp <- timestamp[accStart]
  accEndStamp <- timestamp[accEnd]
  accTimeDiff <- accEndStamp - accStartStamp
  return(sum(accTimeDiff >= timeThreshold))
}

  
player1accs <- accCounter(player1$acceleration, 2, player1$timestamp, 0.5)  
player1accs  
  

accDistance <- function(acceleration, accThreshold, timestamp, distance, timeThreshold) {
  accVector <- vector("numeric", length = length(acceleration))
  for (i in 1:length(acceleration)) {
    if (acceleration[i] >= accThreshold) {
      accVector[i] = 1
    }
  }
  accIndex <- rle(accVector)
  accelIndexes <- cumsum(accIndex$lengths)
  if (length(accelIndexes) %% 2 == 1) {
    accelIndexes <- c(accelIndexes, accelIndexes[length(accelIndexes)])
  }
  accStart <- accelIndexes[seq(from = 1, to = length(accelIndexes), by = 2)]
  accEnd <- accelIndexes[seq(from = 2, to = length(accelIndexes), by = 2)]
  accStartStamp <- timestamp[accStart]
  accEndStamp <- timestamp[accEnd]
  accDistStartStamp <- distance[accStart]
  accDistEndStamp <- distance[accEnd]
  accTimeDiff <- accEndStamp - accStartStamp
  accDistDiff <- accDistEndStamp - accDistStartStamp
  return(sum(accDistDiff[accTimeDiff >= timeThreshold]))
}

accDistanceP1 <- accDistance(player1$acceleration, 2, player1$timestamp, player1$total_distance, 0.5)

vecHirDistance <- vector("numeric", length = length(player1$speed_km.h))
for (i in 1:length(player1$total_distance)) {
    if (player1$speed_km.h[i] >= 19.8 & player1$speed_km.h[i] <= 25.2) {
      vecHirDistance[i] = 1
    }
}

hirIndex <- rle(vecHirDistance)
hirIndexes <- cumsum(hirIndex$lengths)
  if (length(hirIndexes) %% 2 == 1) {
    hirIndexes <- c(hirIndexes, hirIndexes[length(hirIndexes)])
  }
  hirStart <- hirIndexes[seq(from = 1, to = length(hirIndexes), by = 2)]
  hirEnd <- hirIndexes[seq(from = 2, to = length(hirIndexes), by = 2)]
  hirStartDist <- player1$total_distance[hirStart]
  hirEndDist <- player1$total_distance[hirEnd]
  hirDistanceRun <- hirEndDist - hirStartDist
  sum(hirDistanceRun >= 36 & hirDistanceRun <= 40)





player1_200_380 <- player1[player1$seconds >200 & player1$seconds < 380,]

ggplot(data = player1,
 aes(x = seconds, y = speed_km.h, color = speed_km.h)) +
 geom_line() +
 scale_colour_gradientn(colours = rainbow(7)) +
 xlab("\n Time (s)") +
 ylab(expression(Velocity ~ (m.s^-1))) +
 scale_x_continuous(limits = c(200, 380), expand = c(0, 0), breaks = seq(200, 380, by = 20)) +
  scale_y_continuous() +
 theme_classic() +
 theme(legend.position = "none") #+ 
  facet_wrap(tag_id ~ .)

clusters <- function(x,y) {
  clusterMatrix <- as.matrix(x[!is.na(x)], ncol = 1)
  nClusters <- y
  set.seed(1)
  k.clusters <- kmeans(clusterMatrix[,1], nClusters)
  return(k.clusters)
}  

accelClusters <- clusters(df_cleaned$acceleration, 3) 
accelClusters$centers

# Add the cluster data info back into the dummy data
df_cleaned$accelCluster <- accelClusters$cluster
df_cleaned$accelNotational <- factor(accelClusters$cluster, levels = 1:length(accelClusters$centers), labels = c("Acceleration", "Neutral", "Deceleration")) #c(as.character(round(accelClusters$centers, 1))))



#specific player datasets
player1 <- df_cleaned[df_cleaned$tag_id == "1",]
player1_200_380 <- player1[player1$seconds >200 & player1$seconds < 380,]

# Create a new column, based on "Centers" data.frame
ggplot(data = df_cleaned, aes(x = NotationalDescriptor, fill = NotationalDescriptor)) +
geom_bar(colour = "black", size = 1) +
xlab("\n Notational Descriptor") +
ylab("Count \n") +
scale_y_continuous() +
theme_classic() +
theme(legend.position = "none")

# Plot based on the notational descriptor
ggplot(data = player1, aes(x = seconds, y = angularDisp, color = NotationalDescriptor, group = 1)) +
geom_line() +
scale_color_manual(values = c("green", "red", "black", "blue")) + 
xlab("\n Time (s)") +
ylab(expression(Velocity ~ (m.s^-1))) +
scale_x_continuous(limits = c(200, 380), breaks = seq(200, 380, by = 20)) +
scale_y_continuous() +
# The line of code below changes the legend heading, when we wish to add a space between words
labs(colour = 'Notational Descriptor') +
theme_classic() +
theme(legend.position = "bottom")  

ggplot(player1_200_380) +
  geom_segment(aes(x = 105, y = 0, xend = 105, yend = Inf)) +
  geom_segment(aes(x = 105/2, y = 0, xend = 105/2, yend = Inf)) +
  geom_segment(aes(x = 40, xend = 105, y = 0, yend = 0)) +
  geom_segment(aes(x = 105 - 16.5, xend = 105, y = 68/2 - 20.15, yend = 68/2 - 20.15)) +
  geom_segment(aes(x = 105 - 16.5, xend = 105 - 16.5, y = 68/2 - 20.15, yend = Inf)) +
  geom_segment(aes(x = 105 - 5.5, xend = 105, y = 68/2 - 9.16, yend = 68/2 - 9.16)) +
  geom_segment(aes(x = 105 - 5.5, xend = 105 - 5.5, y = 68/2 - 9.16, yend = Inf)) +
  #geom_path(aes(x = x_pos, y = y_pos, color = angularDisp)) +
  geom_path(aes(x = x_pos, y = y_pos, color = NotationalDescriptor, group = 1)) +
  scale_color_manual(values = c("green", "red", "black", "blue")) +
  #scale_color_gradientn(colors = rainbow(7)) +
  scale_x_continuous(limits = c(40,105)) +
  coord_fixed() +
  theme_classic() + 
  theme(plot.background = element_blank(), 
        legend.position="bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank())




```

For the pitch I used code from Joe Gallagher's soccermatics package.
```{r}
pitchBG <- function(lengthPitch = 105, widthPitch = 68, fill = "white", colour = "dimgrey", size = 1) 
  {
  ggplot() +
  # perimeter line
  geom_rect(aes(xmin = 0, xmax = lengthPitch, ymin = 0, ymax = widthPitch), fill = fill, colour = colour, size = 1) +
  # centre circle
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 9.15), colour = colour, size = 1) +
  # kick off spot
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 0.25), fill = fill, colour = colour, size = 1) +
  # halfway line
  geom_segment(aes(x = lengthPitch/2, y = 0, xend = lengthPitch/2, yend = widthPitch), colour = colour, size = 1) + # penalty arcs
  geom_arc(aes(x0 = 11, y0 = widthPitch/2, r = 9.15, start = 0.65, end = 2.49), colour = colour, size = 1) +
  geom_arc(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 9.15, start = 3.79, end = 5.63), colour = colour, size = 1) +
  # penalty areas
  geom_rect(aes(xmin = 0, xmax = 16.5, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 16.5, xmax = lengthPitch, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  # penalty spots
  geom_circle(aes(x0 = 11, y0 = widthPitch/2, r = 0.25), fill = colour, col = colour, size = 1) +
  geom_circle(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 0.25), fill = colour, colour = colour, size = 1) +
  # six yard boxes
  geom_rect(aes(xmin = 0, xmax = 5.5, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 5.5, xmax = lengthPitch, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  # goals
  geom_rect(aes(xmin = -2, xmax = 0, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch, xmax = lengthPitch + 2, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  coord_fixed() +
  xlab("") +
  ylab("")
  }
pitchBG()
```


```{r}
avg_positions <- df %>% 
  group_by(tag_id) %>%
  summarise(avg_x = mean(x_pos),
            avg_y = mean(y_pos),
            distance = max(total_distance))

pitchBG() +
  geom_point(aes(avg_x, avg_y),
             data = avg_positions,
             fill = "red", 
             shape = 21,
             size = 7) +
  geom_text(aes(avg_x, avg_y, label = tag_id), data = avg_positions, colour = "white", fontface = "bold", size = 3)
```
The graph shows the average position corresponding to each tag id. As showed 9 tags are outfield players, while 5 look like substitute. Furthermore, by looking "avg_positions" we can see that they haven't run as much either. Using this information we can create a lookup table and name the positions to our dataframe.
```{r}
positionsLookup <- c("2" = "RB", "4" = "RCB", "14" = "LCB", "1" = "LB", "8" = "RM", "11" = "RCM", "6" = "LM", "5" = "ST", "12" = "FW", "9" = "Sub1", "10" = "Sub2", "7" = "Sub3", "13" = "Sub4", "3" = "Sub5")

df$position <- positionsLookup[as.character(df$tag_id)]

starters <- df %>%
  group_by(position) %>%
  filter(max(total_distance) > 1000)
```

```{r}
speedPlot <- ggplot(starters, aes(x = seconds, y = speed_km.h)) +
  geom_path() +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedPlot
```



```{r}
boxPlots <- ggplot(starters, aes(x = position, y = speed_km.h)) +
  geom_boxplot() +
  theme_minimal()
boxPlots
```

```{r}
outliers <- boxplot(starters$speed_km.h, plot = FALSE)$out
outliers
```







```{r}
speedHisto <- ggplot(starters, aes(speed_km.h)) +
  geom_histogram(binwidth = 1) +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedHisto
```
Let's calculate acceleration:
```{r}
startersCleaned <- starters
startersCleaned$speed <- replace(startersCleaned$speed, startersCleaned$speed == 0, NA)

startersCleaned <- startersCleaned %>%
  group_by(position) %>%
  mutate(acceleration = c(NA, diff(speed)/diff(seconds)))

accelPlot <- ggplot(startersCleaned, aes(x = seconds, y = acceleration)) +
  geom_path() +
  theme_classic() +
  facet_wrap(~ position, ncol = 3)
accelPlot
```
```{r}
rle(startersCleaned$speed > 9)