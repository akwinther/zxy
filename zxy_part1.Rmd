---
title: "Working with ZXY data part 1"
author: "Andreas K. Winther"
date: "5/28/2019"
output: html_document
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction

In this post we'll calculate some basic tracking metrics using the ZXY data from Pettersen et al 2014. 

```{r echo=FALSE, message=FALSE}
install.packages("Rcpp", repos = "http://cran.us.r-project.org")
install.packages("ggforce", repos = "http://cran.us.r-project.org")
library(ggforce)
library(dplyr)
library(zoo)
library(ggplot2)
```

The data can easily be imported by typing the followig code:
```{r}
df <- read.csv("http://home.ifi.uio.no/paalh/dataset/alfheim/2013-11-03/zxy/2013-11-03_tromso_stromsgodset_first.csv", header = FALSE)
```

Let's start by changing the names of the variables, and adding a column with the time elapsed in seconds.
```{r}
names(df) <- c("timestamp", "tag_id", "x_pos", "y_pos", "heading", "direction", "energy", "speed", "total_distance")

options(digits.secs = 6)
df$timestamp <- as.POSIXct(df$timestamp,format = "%Y-%m-%d %H:%M:%OS")
df$seconds <- as.numeric(df$timestamp - min(df$timestamp))
df$minutes <- df$seconds/60
```

We are also going to add some common tracking metrics, namely cumulative high-intensity distance, cumulative sprint distance, and acceleration. 

```{r}
df <- df %>%
  group_by(tag_id) %>%
  mutate(distance = (sqrt((x_pos - lag(x_pos))^2 + (y_pos - lag(y_pos))^2)),
         speed_km.h = (speed * 3.6),
         hir_distance = (cumsum(ifelse(speed_km.h >=19.8 & speed_km.h <= 25.2, distance, 0))),
         sprint_distance = (cumsum(ifelse(speed_km.h > 25.2, distance, 0))),
         acceleration = c(NA, diff(speed)) / c(NA, diff(timestamp)))
```

As showed by @andreassen2019real the number of occurences and the distance covered during events such as sprints, high intensity runs (HIR), and accelerations, can easily be extracted from this kind of data. In said paper these events are defined as follows:
HIR = A run at a speed faster than $5.5\,m.s^{-1}$ or $19.8\,km.h^{-1}$, over a time period of 1 second,
Sprint = A run at a speed faster than $7.0\,m.s^{âˆ’1}$ over a time period greater than 1 seconds is said to be a sprint,
and
Acceleration = a change of speed over $2.0\,m.s^{2}$ over a duration of 0.5 seconds.

To extract these events we're going to use a base R function called "rle" or "run length encoding". Rle captures the "run length" of events, which is useful in our case because we want to capture the duration in which the speed or acceleration is over a certain threshold. This can be done as follows:

```{r}
counter <- function(metric, threshold, timestamp, timeThreshold) {
  metricVector <- vector("numeric", length = length(metric))
  for (i in 1:length(metric)) {
    if (metric[i] > threshold) {
      metricVector[i] = 1
    }
  }
  rleMetric <- rle(metricVector)
  indices <- cumsum(rleMetric$lengths)
  if (length(indices) %% 2 == 1) {
    indices <- c(indices, indices[length(indices)])
  }
  metricStart <- indices[seq(from = 1, to = length(indices), by = 2)]
  metricEnd <- indices[seq(from = 2, to = length(indices), by = 2)]
  metricStartStamp <- timestamp[metricStart]
  metricEndStamp <- timestamp[metricEnd]
  metricTimeDiff <- metricEndStamp - metricStartStamp
  return(sum(metricTimeDiff > timeThreshold))
}
```

Now, let's use this function to find how many accelerations and sprints some players did in the first half:

```{r}
df %>%
  group_by(tag_id) %>%
  summarise(accelerations = counter(na.omit(acceleration), 2, timestamp, 0.8), 
            sprints = counter(speed, 7, timestamp, 1)) %>%
  filter(tag_id %in% c(1,7,9))
```

```{r}
metricDistance <- function(metric, metricThreshold, timestamp, distance, timeThreshold) {
  metricVector <- vector("numeric", length = length(metric))
  for (i in 1:length(metric)) {
    if (metric[i] >= metricThreshold) {
      metricVector[i] = 1
    }
  }
  metricIndex <- rle(metricVector)
  metricIndexes <- cumsum(metricIndex$lengths)
  if (length(metricIndexes) %% 2 == 1) {
    metricIndexes <- c(metricIndexes, metricIndexes[length(metricIndexes)])
  }
  metricStart <- metricIndexes[seq(from = 1, to = length(metricIndexes), by = 2)]
  metricEnd <- metricIndexes[seq(from = 2, to = length(metricIndexes), by = 2)]
  metricStartStamp <- timestamp[metricStart] #Subsets indices in "timestamp"" where a sprint or acceleration starts
  metricEndStamp <- timestamp[metricEnd] #Subsets indices in "timestamp" where" a sprint or acceleration ends 
  metricDistStartStamp <- distance[metricStart] #Subsets indices in "distance" where a sprint or acceleration starts
  metricDistEndStamp <- distance[metricEnd] #Subsets indices in "distance" where a sprint or acceleration ends
  metricTimeDiff <- metricEndStamp - metricStartStamp #Calculates the time between sprint/accleration start and end
  metricDistDiff <- metricDistEndStamp - metricDistStartStamp #Calculates the distance between sprint/acceleration start and end
  return(sum(metricDistDiff[metricTimeDiff >= timeThreshold])) #Returns the total distance of sprint/accelerations where the time is over a certian threshold
}

df %>%
  group_by(tag_id) %>%
  summarise(accelDist = metricDistance(na.omit(acceleration), 2, timestamp, total_distance, 0.8),
            sprintDist = metricDistance(speed, 7, timestamp, total_distance, 1),
            minutes = max(minutes),
            workRateAccel = accelDist/minutes,
            workRateSprint = sprintDist/minutes) %>%
  filter(tag_id %in% c(1,7,9))
```


```{r}
sprintDistance <- function(speed, speedThreshold, timestamp, distance, timeThreshold) {
  sprintVector <- vector("numeric", length = length(speed))
  for (i in 1:length(speed)) {
    if (speed[i] > speedThreshold) {
      sprintVector[i] = 1
    }
  }
  sprintIndex <- rle(sprintVector)
  sprintIndexes <- cumsum(sprintIndex$lengths)
  if (length(sprintIndexes) %% 2 == 1) {
    sprintIndexes <- c(sprintIndexes, sprintIndexes[length(sprintIndexes)])
  }
  sprintStart <- sprintIndexes[seq(from = 1, to = length(sprintIndexes), by = 2)]
  sprintEnd <- sprintIndexes[seq(from = 2, to = length(sprintIndexes), by = 2)]
  sprintStartStamp <- timestamp[sprintStart] #Subsets timestamp indexes where a sprint starts
  sprintEndStamp <- timestamp[sprintEnd] #Subsets timestamp indexes where a sprint ends
  sprintDistStartStamp <- distance[sprintStart] #Subsets distance indexes where a sprint starts 
  sprintDistEndStamp <- distance[sprintEnd] #Subsets distance indexes where a sprint ends 
  sprintTimeDiff <- sprintEndStamp - sprintStartStamp #Calculates the time difference between sprint start and end
  sprintDistDiff <- sprintDistEndStamp - sprintDistStartStamp
  return(sprintDistDiff >= 1 & sprintDistDiff <= 5)
  
  #return(sprintDistDiff[sprintTimeDiff > timeThreshold])
}

sprintDistance(p1$speed,7,p1$timestamp,p1$total_distance,1)


vecHirDistance <- vector("numeric", length = length(player1$speed_km.h))
  for (i in 1:length(player1$total_distance)) {
    if (player1$speed_km.h[i] >= 19.8 & player1$speed_km.h[i] <= 25.2) {
      vecHirDistance[i] = 1
    }
}

hirIndex <- rle(vecHirDistance)
hirIndexes <- cumsum(hirIndex$lengths)
  if (length(hirIndexes) %% 2 == 1) {
    hirIndexes <- c(hirIndexes, hirIndexes[length(hirIndexes)])
  }
  hirStart <- hirIndexes[seq(from = 1, to = length(hirIndexes), by = 2)]
  hirEnd <- hirIndexes[seq(from = 2, to = length(hirIndexes), by = 2)]
  hirStartDist <- player1$total_distance[hirStart]
  hirEndDist <- player1$total_distance[hirEnd]
  hirDistanceRun <- hirEndDist - hirStartDist
  sum(hirDistanceRun >= 36 & hirDistanceRun <= 40)



```

##Clustering


         
The ZXY system has a unique metric called "Turns" which basically measures how much the player is turning or changing direction. This metric is not featured in the dataset, but can be found in this paper by Baptista. Here it is defined as "a continuous and significant rotation of the body in one direction (derived from gyroscope and compass data)". Though, I have no idea if this metric can be derived using the published dataset. What I do know based this paper by @sweeting1232014movement is that we can calculate the angular displacement based on the x,y coordinates. This is done by calculating the dot product of consecutive movement vectors, as follows:

$\theta_{i} = cos^{-1}[\,\frac{a*b}{\|a\|*\|b\|}]\,$  

```{r}
rad2deg <- function(rad) {(rad * 180) / (pi)} #Creates a function that translates radians into degrees.

df <- df %>%
  group_by(tag_id) %>%
  mutate(vectorCompX = c(NA,diff(x_pos)),
         vectorCompY = c(NA, diff(y_pos)),
         vectorLength = sqrt(((vectorCompX^2) + (vectorCompY^2))),
         prodVectorLength = vectorLength * lead(vectorLength),
         dotProd = vectorCompX * lead(vectorCompX) + vectorCompY * lead(vectorCompY),
         angularDisp = rad2deg(acos(dotProd/prodVectorLength))) %>%
  arrange(tag_id)
```


#specific player datasets
player1 <- df_cleaned[df_cleaned$tag_id == "1",]









player1_200_380 <- player1[player1$seconds >200 & player1$seconds < 380,]

ggplot(data = player1,
 aes(x = seconds, y = speed_km.h, color = speed_km.h)) +
 geom_line() +
 scale_colour_gradientn(colours = rainbow(7)) +
 xlab("\n Time (s)") +
 ylab(expression(Velocity ~ (m.s^-1))) +
 scale_x_continuous(limits = c(200, 380), expand = c(0, 0), breaks = seq(200, 380, by = 20)) +
  scale_y_continuous() +
 theme_classic() +
 theme(legend.position = "none") #+ 
  facet_wrap(tag_id ~ .)

clusters <- function(x,y) {
  clusterMatrix <- as.matrix(x[!is.na(x)], ncol = 1)
  nClusters <- y
  set.seed(1)
  k.clusters <- kmeans(clusterMatrix[,1], nClusters)
  return(k.clusters)
}  

accelClusters <- clusters(df_cleaned$acceleration, 3) 
accelClusters$centers

# Add the cluster data info back into the dummy data
df_cleaned$accelCluster <- accelClusters$cluster
df_cleaned$accelNotational <- factor(accelClusters$cluster, levels = 1:length(accelClusters$centers), labels = c("Acceleration", "Neutral", "Deceleration")) #c(as.character(round(accelClusters$centers, 1))))



#specific player datasets
player1 <- df_cleaned[df_cleaned$tag_id == "1",]
player1_200_380 <- player1[player1$seconds >200 & player1$seconds < 380,]

# Create a new column, based on "Centers" data.frame
ggplot(data = df_cleaned, aes(x = NotationalDescriptor, fill = NotationalDescriptor)) +
geom_bar(colour = "black", size = 1) +
xlab("\n Notational Descriptor") +
ylab("Count \n") +
scale_y_continuous() +
theme_classic() +
theme(legend.position = "none")

# Plot based on the notational descriptor
ggplot(data = player1, aes(x = seconds, y = angularDisp, color = NotationalDescriptor, group = 1)) +
geom_line() +
scale_color_manual(values = c("green", "red", "black", "blue")) + 
xlab("\n Time (s)") +
ylab(expression(Velocity ~ (m.s^-1))) +
scale_x_continuous(limits = c(200, 380), breaks = seq(200, 380, by = 20)) +
scale_y_continuous() +
# The line of code below changes the legend heading, when we wish to add a space between words
labs(colour = 'Notational Descriptor') +
theme_classic() +
theme(legend.position = "bottom")  

ggplot(player1_200_380) +
  geom_segment(aes(x = 105, y = 0, xend = 105, yend = Inf)) +
  geom_segment(aes(x = 105/2, y = 0, xend = 105/2, yend = Inf)) +
  geom_segment(aes(x = 40, xend = 105, y = 0, yend = 0)) +
  geom_segment(aes(x = 105 - 16.5, xend = 105, y = 68/2 - 20.15, yend = 68/2 - 20.15)) +
  geom_segment(aes(x = 105 - 16.5, xend = 105 - 16.5, y = 68/2 - 20.15, yend = Inf)) +
  geom_segment(aes(x = 105 - 5.5, xend = 105, y = 68/2 - 9.16, yend = 68/2 - 9.16)) +
  geom_segment(aes(x = 105 - 5.5, xend = 105 - 5.5, y = 68/2 - 9.16, yend = Inf)) +
  #geom_path(aes(x = x_pos, y = y_pos, color = angularDisp)) +
  geom_path(aes(x = x_pos, y = y_pos, color = NotationalDescriptor, group = 1)) +
  scale_color_manual(values = c("green", "red", "black", "blue")) +
  #scale_color_gradientn(colors = rainbow(7)) +
  scale_x_continuous(limits = c(40,105)) +
  coord_fixed() +
  theme_classic() + 
  theme(plot.background = element_blank(), 
        legend.position="bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank())




```

For the pitch I used code from Joe Gallagher's soccermatics package.
```{r}
pitchBG <- function(lengthPitch = 105, widthPitch = 68, fill = "white", colour = "dimgrey", size = 1) 
  {
  ggplot() +
  # perimeter line
  geom_rect(aes(xmin = 0, xmax = lengthPitch, ymin = 0, ymax = widthPitch), fill = fill, colour = colour, size = 1) +
  # centre circle
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 9.15), colour = colour, size = 1) +
  # kick off spot
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 0.25), fill = fill, colour = colour, size = 1) +
  # halfway line
  geom_segment(aes(x = lengthPitch/2, y = 0, xend = lengthPitch/2, yend = widthPitch), colour = colour, size = 1) + # penalty arcs
  geom_arc(aes(x0 = 11, y0 = widthPitch/2, r = 9.15, start = 0.65, end = 2.49), colour = colour, size = 1) +
  geom_arc(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 9.15, start = 3.79, end = 5.63), colour = colour, size = 1) +
  # penalty areas
  geom_rect(aes(xmin = 0, xmax = 16.5, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 16.5, xmax = lengthPitch, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  # penalty spots
  geom_circle(aes(x0 = 11, y0 = widthPitch/2, r = 0.25), fill = colour, col = colour, size = 1) +
  geom_circle(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 0.25), fill = colour, colour = colour, size = 1) +
  # six yard boxes
  geom_rect(aes(xmin = 0, xmax = 5.5, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 5.5, xmax = lengthPitch, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  # goals
  geom_rect(aes(xmin = -2, xmax = 0, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch, xmax = lengthPitch + 2, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  coord_fixed() +
  xlab("") +
  ylab("")
  }
pitchBG()
```


```{r}
avg_positions <- df %>% 
  group_by(tag_id) %>%
  summarise(avg_x = mean(x_pos),
            avg_y = mean(y_pos),
            distance = max(total_distance))

pitchBG() +
  geom_point(aes(avg_x, avg_y),
             data = avg_positions,
             fill = "red", 
             shape = 21,
             size = 7) +
  geom_text(aes(avg_x, avg_y, label = tag_id), data = avg_positions, colour = "white", fontface = "bold", size = 3)
```
The graph shows the average position corresponding to each tag id. As showed 9 tags are outfield players, while 5 look like substitute. Furthermore, by looking "avg_positions" we can see that they haven't run as much either. Using this information we can create a lookup table and name the positions to our dataframe.
```{r}
positionsLookup <- c("2" = "RB", "4" = "RCB", "14" = "LCB", "1" = "LB", "8" = "RM", "11" = "RCM", "6" = "LM", "5" = "ST", "12" = "FW", "9" = "Sub1", "10" = "Sub2", "7" = "Sub3", "13" = "Sub4", "3" = "Sub5")

df$position <- positionsLookup[as.character(df$tag_id)]

starters <- df %>%
  group_by(position) %>%
  filter(max(total_distance) > 1000)
```

```{r}
speedPlot <- ggplot(starters, aes(x = seconds, y = speed_km.h)) +
  geom_path() +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedPlot
```



```{r}
boxPlots <- ggplot(starters, aes(x = position, y = speed_km.h)) +
  geom_boxplot() +
  theme_minimal()
boxPlots
```

```{r}
outliers <- boxplot(starters$speed_km.h, plot = FALSE)$out
outliers
```







```{r}
speedHisto <- ggplot(starters, aes(speed_km.h)) +
  geom_histogram(binwidth = 1) +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedHisto
```
Let's calculate acceleration:
```{r}
startersCleaned <- starters
startersCleaned$speed <- replace(startersCleaned$speed, startersCleaned$speed == 0, NA)

startersCleaned <- startersCleaned %>%
  group_by(position) %>%
  mutate(acceleration = c(NA, diff(speed)/diff(seconds)))

accelPlot <- ggplot(startersCleaned, aes(x = seconds, y = acceleration)) +
  geom_path() +
  theme_classic() +
  facet_wrap(~ position, ncol = 3)
accelPlot
```
```{r}
rle(startersCleaned$speed > 9)