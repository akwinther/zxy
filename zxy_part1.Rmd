---
title: "Working with ZXY data part 1"
author: "Andreas K. Winther"
date: "5/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction

In this post we'll do some basic data vizualization using the ZXY data from Pettersen et al 2014. 

```{r echo=FALSE, message=FALSE}
library(ggplot2)
install.packages("ggforce")
library(ggforce)
library(dplyr)
library(zoo)
```

The data can easily be imported by typing the followig code:
```{r}
df <- read.csv("http://home.ifi.uio.no/paalh/dataset/alfheim/2013-11-28/zxy/2013-11-28_tromso_tottenham_raw.csv", header = FALSE)
```

Let's start by changing the names of the variables, and adding a column with the time elapsed in seconds.
```{r}
names(df) <- c("timestamp", "tag_id", "x_pos", "y_pos", "heading", "direction", "energy", "speed", "total_distance")

options(digits.secs = 6)
df$timestamp <- as.POSIXct(df$timestamp,format = "%Y-%m-%d %H:%M:%OS")
df$seconds <- as.numeric(df$timestamp - min(df$timestamp))

df <- df %>%
  group_by(tag_id) %>%
  mutate(distance = (sqrt((x_pos - lag(x_pos))^2 + (y_pos - lag(y_pos))^2)),
         speed_km.h = (speed * 3.6), 
         hir_distance = (cumsum(ifelse(speed_km.h >=19.8 & speed_km.h <= 25.2, distance, 0))),
         sprint_distance = (cumsum(ifelse(speed_km.h > 25.2, distance, 0))),
         acceleration = c(NA, diff(speed)/diff(seconds)),
         accel_moderate = (ifelse(acceleration >= 2 & acceleration <= 4, acceleration, 0)),
         accel_high = (ifelse(acceleration > 4, acceleration, 0)),
         decel_moderate = (ifelse(acceleration <=-2 & acceleration >=-4, acceleration, 0)),
         decel_high = (ifelse(acceleration < -4, acceleration, 0)),
         vectorCompX = c(NA,diff(x_pos)),
         vectorCompY = c(NA, diff(y_pos)),
         vectorLength = sqrt((vectorCompX^2) + (vectorCompY^2)),
         prodVectorLength = vectorLength * lead(vectorLength),
         dotProd = vectorCompX * lead(vectorCompX) + vectorCompY * lead(vectorCompY),
         angularDisp = rad2deg(acos(dotProd/prodVectorLength)),
         angularVelocity = abs(c(NA, diff(angularDisp)/diff(seconds)))) %>%
  arrange(tag_id)

rad2deg <- function(rad) {(rad * 180) / (pi)}

df_cleaned <- df %>%
  filter(speed_km.h < 37 & acceleration < 6 & acceleration > -6 & angularVelocity < 360) 

outliers <- subset(df, speed_km.h > 37 | angularVelocity > 360 | acceleration > 6 | acceleration < -6 )

df_stats <- df_cleaned %>%
  group_by(tag_id, position) %>%
  summarise(total_distance = max(total_distance),
            sprint_counts = sum(rle(speed_km.h > 25.2)$values, na.rm = FALSE),
            hir_counts = sum(rle(speed_km.h >=19.8 & speed_km.h <= 25.2)$values, na.rm = TRUE),
            accel_mod_counts = sum(rle(acceleration >= 2 & acceleration <= 4)$values, na.rm = TRUE),
            accel_high_counts = sum(rle(acceleration > 4)$values, na.rm = FALSE),
            decel_mod_counts = sum(rle(acceleration <=-2 & acceleration >=-4)$values, na.rm = TRUE),
            decel_high_counts = sum(rle(acceleration < -4)$values, na.rm = TRUE))

player1 <- df_cleaned[df_cleaned$tag_id == "1",]

ggplot(data = player1,
 aes(x = seconds, y = acceleration, color = acceleration)) +
 geom_point() +
 scale_colour_gradientn(colours = rainbow(7)) +
 xlab("\n Time (s)") +
 ylab(expression(Velocity ~ (m.s^-1))) +
 scale_x_continuous(limits = c(200, 2000), expand = c(0, 0), breaks = seq(200, 2000, by = 200)) +
  scale_y_continuous() +
 theme_classic() +
 theme(legend.position = "none") #+ 
  facet_wrap(tag_id ~ .)

# Perform k-means clustering on the angular velocity column
# First place the column into a matrix
matrixAngularVelocity <- as.matrix(df_cleaned$angularVelocity[!is.na(df_cleaned$angularVelocity)], ncol=1)
# Declare the number of clusters, for example, four groups of velocity
nAngularVelocityClusters <- 4
# Ensure the initial cluster points are held constant
set.seed(1)
# Obtain the kMeans cluster
AngularVelocityClusters <- kmeans(matrixAngularVelocity[,1], nAngularVelocityClusters)
# To obtain the centers, size and within cluster sum of squares
AngularVelocityClusters$centers
AngularVelocityClusters$size
AngularVelocityClusters$withinss

AngularVelocityCluster_df <- data.frame(AngularVelocityClusters$cluster)
colnames(AngularVelocityCluster_df) <- "Cluster"
AngularVelocityCluster_df$Notational <- factor(AngularVelocityCluster_df$Cluster, levels = c(1,2,3,4,5), labels = c("45", "Straight", "Curved", "U-turn", "90"))

#levels = c(1,2,3,4,5), labels = c("45", "Straight", "Curved", "U-turn", "90"))                                               
#levels = c(1,2,3,4), labels = c("65", "U-turn", "Curved", "Straight"))   
  
```

For the pitch I used code from Joe Gallagher's soccermatics package.
```{r}
pitchBG <- function(lengthPitch = 105, widthPitch = 68, fill = "white", colour = "dimgrey", size = 1) 
  {
  ggplot() +
  # perimeter line
  geom_rect(aes(xmin = 0, xmax = lengthPitch, ymin = 0, ymax = widthPitch), fill = fill, colour = colour, size = 1) +
  # centre circle
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 9.15), colour = colour, size = 1) +
  # kick off spot
  geom_circle(aes(x0 = lengthPitch/2, y0 = widthPitch/2, r = 0.25), fill = fill, colour = colour, size = 1) +
  # halfway line
  geom_segment(aes(x = lengthPitch/2, y = 0, xend = lengthPitch/2, yend = widthPitch), colour = colour, size = 1) + # penalty arcs
  geom_arc(aes(x0 = 11, y0 = widthPitch/2, r = 9.15, start = 0.65, end = 2.49), colour = colour, size = 1) +
  geom_arc(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 9.15, start = 3.79, end = 5.63), colour = colour, size = 1) +
  # penalty areas
  geom_rect(aes(xmin = 0, xmax = 16.5, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 16.5, xmax = lengthPitch, ymin = widthPitch/2 - 20.15, ymax = widthPitch/2 + 20.15), fill = NA, colour = colour, size = 1) +
  # penalty spots
  geom_circle(aes(x0 = 11, y0 = widthPitch/2, r = 0.25), fill = colour, col = colour, size = 1) +
  geom_circle(aes(x0 = lengthPitch - 11, y0 = widthPitch/2, r = 0.25), fill = colour, colour = colour, size = 1) +
  # six yard boxes
  geom_rect(aes(xmin = 0, xmax = 5.5, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch - 5.5, xmax = lengthPitch, ymin = (widthPitch/2) - 9.16, ymax = (widthPitch/2) + 9.16), fill = NA, colour = colour, size = 1) +
  # goals
  geom_rect(aes(xmin = -2, xmax = 0, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  geom_rect(aes(xmin = lengthPitch, xmax = lengthPitch + 2, ymin = (widthPitch/2) - 3.66, ymax = (widthPitch/2) + 3.66), fill = NA, colour = colour, size = 1) +
  coord_fixed() +
  xlab("") +
  ylab("")
  }
pitchBG()
```


```{r}
avg_positions <- df %>% 
  group_by(tag_id) %>%
  summarise(avg_x = mean(x_pos),
            avg_y = mean(y_pos),
            distance = max(total_distance))

pitchBG() +
  geom_point(aes(avg_x, avg_y),
             data = avg_positions,
             fill = "red", 
             shape = 21,
             size = 7) +
  geom_text(aes(avg_x, avg_y, label = tag_id), data = avg_positions, colour = "white", fontface = "bold", size = 3)
```
The graph shows the average position corresponding to each tag id. As showed 9 tags are outfield players, while 5 look like substitute. Furthermore, by looking "avg_positions" we can see that they haven't run as much either. Using this information we can create a lookup table and name the positions to our dataframe.
```{r}
positionsLookup <- c("2" = "RB", "4" = "RCB", "14" = "LCB", "1" = "LB", "8" = "RM", "11" = "RCM", "6" = "LM", "5" = "ST", "12" = "FW", "9" = "Sub1", "10" = "Sub2", "7" = "Sub3", "13" = "Sub4", "3" = "Sub5")

df$position <- positionsLookup[as.character(df$tag_id)]

starters <- df %>%
  group_by(position) %>%
  filter(max(total_distance) > 1000)
```

```{r}
speedPlot <- ggplot(starters, aes(x = seconds, y = speed_km.h)) +
  geom_path() +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedPlot
```



```{r}
boxPlots <- ggplot(starters, aes(x = position, y = speed_km.h)) +
  geom_boxplot() +
  theme_minimal()
boxPlots
```

```{r}
outliers <- boxplot(starters$speed_km.h, plot = FALSE)$out
outliers
```







```{r}
speedHisto <- ggplot(starters, aes(speed_km.h)) +
  geom_histogram(binwidth = 1) +
  theme_minimal() +
  facet_wrap(~ position, ncol = 3)
speedHisto
```
Let's calculate acceleration:
```{r}
startersCleaned <- starters
startersCleaned$speed <- replace(startersCleaned$speed, startersCleaned$speed == 0, NA)

startersCleaned <- startersCleaned %>%
  group_by(position) %>%
  mutate(acceleration = c(NA, diff(speed)/diff(seconds)))

accelPlot <- ggplot(startersCleaned, aes(x = seconds, y = acceleration)) +
  geom_path() +
  theme_classic() +
  facet_wrap(~ position, ncol = 3)
accelPlot
```
```{r}
rle(startersCleaned$speed > 9)